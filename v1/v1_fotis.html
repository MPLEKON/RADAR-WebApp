<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Fixed-Axis Chart: Static & Real-Time with CSV Loader</title>
    <!-- Bootstrap CSS -->
    <link 
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" 
      rel="stylesheet" 
      crossorigin="anonymous">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Papa Parse -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  </head>
  <body>
    <div class="container my-4">
      <h1 class="text-center mb-4">Fixed-Axis Chart with CSV Loader</h1>
      
      <!-- Dropdown for Plot Type (X–Y or Y–Z) -->
      <div class="mb-3 text-center">
        <label for="plotSelect" class="form-label me-2">Plot Type:</label>
        <select id="plotSelect" class="form-select d-inline-block w-auto">
          <option value="xy" selected>X–Y</option>
          <option value="yz">Y–Z</option>
        </select>
      </div>
      
      <!-- Dropdown for Mode (Real-Time or Static) -->
      <div class="mb-3 text-center">
        <label for="modeSelect" class="form-label me-2">Mode:</label>
        <select id="modeSelect" class="form-select d-inline-block w-auto">
          <option value="realtime" selected>Real-Time</option>
          <option value="static">Static</option>
        </select>
      </div>
      
      <!-- Control Buttons -->
      <div class="mb-3 text-center">
        <button id="startBtn" class="btn btn-primary me-2">Start</button>
        <button id="stopBtn" class="btn btn-secondary me-2">Stop</button>
        <button id="resetBtn" class="btn btn-danger me-2">Reset</button>
        <button id="loadCsvBtn" class="btn btn-info">Load New CSV</button>
      </div>
      
      <div class="card">
        <div class="card-body" style="height: 70vh;">
          <canvas id="myChart"></canvas>
        </div>
      </div>
    </div>

    <!-- Import external CSV data and parsing module via ES6 modules -->
    <script type="module" src="csvFotis.js"></script>
    <script type="module">
      import { csvData as initialCsvData } from "./csvFotis.js";
      import { parseAndCleanCSV } from "./dataParser.js";

      // Use let so that cleanedData can be updated later.
      let cleanedData = parseAndCleanCSV(initialCsvData);
      console.log("Cleaned Data:", cleanedData);
      if (cleanedData.length === 0) {
        console.warn("No valid frames found. Chart won't be updated.");
      }

      // Function to compute overall bounds from cleanedData
      function computeBounds() {
        const allXValues = cleanedData.flatMap(frame => frame.points.map(pt => pt.x));
        const allYValues = cleanedData.flatMap(frame => frame.points.map(pt => pt.y));
        const allZValues = cleanedData.flatMap(frame => frame.points.map(pt => pt.z));

        // For X-Y mode:
        const xyBounds = {
          xMin: Math.min(...allXValues),
          xMax: Math.max(...allXValues),
          yMin: 0, // Force vertical axis to start at 0
          yMax: Math.max(...allYValues)
        };

        // For Y-Z mode:
        // Horizontal axis forced from 0 to overall max of Y.
        const yzBounds = {
          xMin: 0,
          xMax: Math.max(...allYValues),
          yMin: Math.min(...allZValues),
          yMax: Math.max(...allZValues)
        };

        return { xyBounds, yzBounds };
      }

      let { xyBounds, yzBounds } = computeBounds();
      console.log("XY Bounds:", xyBounds);
      console.log("YZ Bounds:", yzBounds);

      let chart;
      let intervalId;
      let currentIndex = 0;
      const updateInterval = 50; // 50ms

      // Mapping function based on the plot selection.
      function getMappingFunction() {
        const selection = document.getElementById("plotSelect").value;
        if (selection === "xy") {
          return pt => ({ x: pt.x, y: pt.y });
        } else {
          return pt => ({ x: pt.y, y: pt.z });
        }
      }

      // Update chart scales based on the selected plot type.
      // For X-Y: horizontal axis from xyBounds.xMin to xyBounds.xMax, vertical fixed from 0 to xyBounds.yMax.
      // For Y-Z: horizontal axis forced to 0 to overall Y max, vertical axis uses real Z range.
      function updateChartScales() {
        const selection = document.getElementById("plotSelect").value;
        if (selection === "xy") {
          chart.options.scales.x.min = xyBounds.xMin;
          chart.options.scales.x.max = xyBounds.xMax;
          chart.options.scales.x.title.text = "X (m)";
          chart.options.scales.y.title.text = "Y (m)";
          chart.options.scales.y.min = 0;
          chart.options.scales.y.max = xyBounds.yMax;
        } else {
          chart.options.scales.x.min = yzBounds.xMin;
          chart.options.scales.x.max = yzBounds.xMax;
          chart.options.scales.x.title.text = "Y (m)";
          chart.options.scales.y.title.text = "Z (m)";
          chart.options.scales.y.min = yzBounds.yMin;
          chart.options.scales.y.max = yzBounds.yMax;
        }
        chart.update('none');
      }

      // Initialize the chart with fixed axes and no animation.
      function initChart() {
        const ctx = document.getElementById("myChart").getContext("2d");
        chart = new Chart(ctx, {
          type: "scatter",
          data: {
            datasets: [{
              label: "Data",
              data: [],
              backgroundColor: "rgba(75, 192, 192, 0.6)",
              borderColor: "rgba(75, 192, 192, 1)"
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                title: { display: true, text: "X (m)" },
                min: xyBounds.xMin,
                max: xyBounds.xMax
              },
              y: {
                title: { display: true, text: "Y (m)" },
                min: 0,
                max: xyBounds.yMax
              }
            }
          }
        });
      }

      // Start updates: in "static" mode, plot all points; in "realtime", one frame at a time.
      function start() {
        const mode = document.getElementById("modeSelect").value;
        const mapping = getMappingFunction();
        if (mode === "static") {
          const allPoints = cleanedData.flatMap(frame => frame.points.map(mapping));
          chart.data.datasets[0].data = allPoints;
          chart.update();
          currentIndex = cleanedData.length;
          return;
        }
        if (intervalId || cleanedData.length === 0) return;
        intervalId = setInterval(() => {
          if (currentIndex >= cleanedData.length) {
            stop();
            return;
          }
          const frame = cleanedData[currentIndex];
          const newPoints = frame.points.map(mapping);
          chart.data.datasets[0].data = newPoints;
          chart.update();
          currentIndex++;
        }, updateInterval);
      }

      function stop() {
        clearInterval(intervalId);
        intervalId = null;
      }

      function resetChart() {
        stop();
        currentIndex = 0;
        chart.data.datasets[0].data = [];
        chart.update();
      }

      // Event listener for plot type dropdown change.
      document.getElementById("plotSelect").addEventListener("change", () => {
        updateChartScales();
        resetChart();
      });

      // Event listener for mode dropdown change.
      document.getElementById("modeSelect").addEventListener("change", () => {
        resetChart();
      });

      // Event listener for the new CSV loader button.
      document.getElementById("loadCsvBtn").addEventListener("click", () => {
        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".csv, text/csv";
        fileInput.addEventListener("change", (event) => {
          const file = event.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              // Re-parse the new CSV data.
              const newCsvData = e.target.result;
              cleanedData = parseAndCleanCSV(newCsvData);
              console.log("New Cleaned Data:", cleanedData);
              // Recompute bounds with the new data.
              const bounds = computeBounds();
              xyBounds.xMin = bounds.xyBounds.xMin;
              xyBounds.xMax = bounds.xyBounds.xMax;
              xyBounds.yMax = bounds.xyBounds.yMax;
              yzBounds.xMax = bounds.yzBounds.xMax;
              yzBounds.yMin = bounds.yzBounds.yMin;
              yzBounds.yMax = bounds.yzBounds.yMax;
              console.log("Updated Bounds:", { xyBounds, yzBounds });
              // Reset the chart.
              resetChart();
              // Update chart scales based on the current plot selection.
              updateChartScales();
            };
            reader.readAsText(file);
          }
        });
        fileInput.click();
      });

      window.addEventListener("DOMContentLoaded", () => {
        initChart();
        document.getElementById("startBtn").addEventListener("click", start);
        document.getElementById("stopBtn").addEventListener("click", stop);
        document.getElementById("resetBtn").addEventListener("click", resetChart);
      });
    </script>

    <!-- Bootstrap JS Bundle (optional) -->
    <script 
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" 
      crossorigin="anonymous">
    </script>
  </body>
</html>
